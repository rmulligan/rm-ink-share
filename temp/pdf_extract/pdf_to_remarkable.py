#!/usr/bin/env python3
"""
PDF to Remarkable Converter

Converts PDF files to Remarkable-compatible format with editable text.
Uses a two-step process:
1. Extract text content from PDF
2. Generate Remarkable document with Lines font for editability

Usage:
    python pdf_to_remarkable.py input.pdf [--output output.rmdoc] [--resolution 229]
"""

import os
import sys
import argparse
import subprocess
import tempfile
import shutil
import json
import uuid
import time
from extract_pdf_text import extract_text_from_pdf

# Paths and constants
TEMP_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp")
DRAWJ2D_PATH = "drawj2d"  # Assumes drawj2d is in the PATH

# Remarkable settings
RM_TITLE_FONT = "Roman"  # Font for titles
RM_BODY_FONT = "Lines"   # Font for body text - ensures editability
RM_FONT_SIZE = 12
RM_MARGIN = 50
RM_LINE_HEIGHT = 30

def ensure_temp_dir():
    """Ensure the temporary directory exists."""
    os.makedirs(TEMP_DIR, exist_ok=True)
    return TEMP_DIR

def create_hcl_from_text(text, title="PDF Document", output_path=None):
    """Create an HCL script for Remarkable with extracted text."""
    if output_path is None:
        temp_dir = ensure_temp_dir()
        output_path = os.path.join(temp_dir, f"pdf_extract_{int(time.time())}.hcl")
    
    # Split text into paragraphs
    paragraphs = text.split("\n\n")
    
    # Format settings
    y_pos = RM_MARGIN + 50
    max_width = 1404 - (2 * RM_MARGIN)
    
    hcl_content = [
        f"# Remarkable document: {title}",
        "# Generated by PDF to Remarkable Converter",
        "",
        "puts \"size 1404 1872\"  # Standard Remarkable size (portrait)",
        "",
        "puts \"pen black\"",
        "puts \"line_width 1\"",
        "",
        f"# Title",
        f"puts \"set_font {RM_TITLE_FONT} 24\"",
        f"puts \"text {RM_MARGIN} {RM_MARGIN} \\\"{title}\\\"\"",
        ""
    ]
    
    for para in paragraphs:
        para = para.strip()
        if not para:
            continue
            
        # Check if paragraph is a heading
        if para.startswith("##"):
            para = para.lstrip("#").strip()
            y_pos += RM_LINE_HEIGHT * 1.5
            
            hcl_content.append(f"# Heading")
            hcl_content.append(f"puts \"set_font {RM_TITLE_FONT} 18\"")
            hcl_content.append(f"puts \"text {RM_MARGIN} {y_pos} \\\"{para}\\\"\"")
            
        # Special line for page breaks
        elif "--- Page Break ---" in para:
            y_pos += RM_LINE_HEIGHT * 2
            hcl_content.append("# Page break in original document")
            hcl_content.append(f"puts \"set_font {RM_BODY_FONT} 10\"")
            hcl_content.append(f"puts \"text {RM_MARGIN} {y_pos} \\\"--- Page Break ---\\\"\"")
            
        # Regular paragraph
        else:
            y_pos += RM_LINE_HEIGHT * 1.5
            
            # Replace any double quotes with escaped quotes for the HCL script
            para = para.replace('\"', '\\\"')
            
            # Truncate extremely long paragraphs to avoid overflow
            if len(para) > 300:
                chunks = [para[i:i+300] for i in range(0, len(para), 300)]
                for chunk in chunks:
                    hcl_content.append(f"puts \"set_font {RM_BODY_FONT} {RM_FONT_SIZE}\"")
                    hcl_content.append(f"puts \"text {RM_MARGIN} {y_pos} \\\"{chunk}\\\"\"")
                    y_pos += RM_LINE_HEIGHT * 1.2
            else:
                hcl_content.append(f"puts \"set_font {RM_BODY_FONT} {RM_FONT_SIZE}\"")
                hcl_content.append(f"puts \"text {RM_MARGIN} {y_pos} \\\"{para}\\\"\"")
            
        y_pos += RM_LINE_HEIGHT
    
    try:
        with open(output_path, 'w', encoding='utf-8') as file:
            file.write("\n".join(hcl_content))
        print(f"HCL script saved to {output_path}")
        return output_path
    except Exception as e:
        print(f"Error saving HCL script: {e}")
        return None

def create_rm_file(hcl_path, output_path=None, resolution=229):
    """Convert HCL script to RM format using drawj2d."""
    if output_path is None:
        base_name = os.path.splitext(hcl_path)[0]
        output_path = f"{base_name}.rm"
    
    try:
        cmd = [DRAWJ2D_PATH, "-Trm", f"-r{resolution}", "-o", output_path, hcl_path]
        print(f"Converting HCL to RM format: {' '.join(cmd)}")
        
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        print(f"RM file created at {output_path}")
        return output_path
    except subprocess.CalledProcessError as e:
        print(f"Error converting to RM format: {e}")
        print(f"Command output: {e.stdout}")
        print(f"Command error: {e.stderr}")
        return None
    except Exception as e:
        print(f"Unexpected error creating RM file: {e}")
        return None

def create_rmdoc_package(rm_path, output_path=None, title="PDF Document"):
    """
    Package RM file into RMDOC format with necessary metadata.
    RMDOC is a zip file containing the RM file and metadata.
    """
    if output_path is None:
        base_name = os.path.splitext(rm_path)[0]
        output_path = f"{base_name}.rmdoc"
    
    # Create a temporary directory for packaging
    temp_dir = tempfile.mkdtemp()
    
    try:
        # Create content directory
        content_dir = os.path.join(temp_dir, "content")
        os.makedirs(content_dir, exist_ok=True)
        
        # Copy RM file
        page_filename = "00000000-0000-0000-0000-000000000000.rm"
        shutil.copy(rm_path, os.path.join(content_dir, page_filename))
        
        # Create metadata.json
        document_id = str(uuid.uuid4())
        metadata = {
            "documentId": document_id,
            "fileType": "notebook",
            "fontName": "",
            "lastModified": int(time.time() * 1000),
            "lineHeight": -1,
            "margins": 100,
            "orientation": "portrait",
            "pageCount": 1,
            "pages": [
                {
                    "id": "00000000-0000-0000-0000-000000000000"
                }
            ],
            "textScale": 1,
            "textiTerata": 0,
            "transform": {
                "m11": 1, "m12": 0, "m13": 0,
                "m21": 0, "m22": 1, "m23": 0,
                "m31": 0, "m32": 0, "m33": 1
            },
            "version": 0
        }
        
        with open(os.path.join(temp_dir, "metadata.json"), 'w') as f:
            json.dump(metadata, f, indent=2)
        
        # Create content.json
        content = {
            "coverPageNumber": -1,
            "documentMetadata": {},
            "fileType": "notebook",
            "fontName": RM_BODY_FONT,
            "formatVersion": 2,
            "lineHeight": 125,
            "margins": 200,
            "orientation": "portrait",
            "pageCount": 1,
            "pages": [
                {
                    "id": "00000000-0000-0000-0000-000000000000"
                }
            ],
            "textAlignment": "left",
            "textScale": 1
        }
        
        with open(os.path.join(content_dir, "content.json"), 'w') as f:
            json.dump(content, f, indent=2)
        
        # Create the zip file (RMDOC)
        shutil.make_archive(output_path[:-6], 'zip', temp_dir)
        
        # Rename the zip file to .rmdoc
        if os.path.exists(output_path):
            os.remove(output_path)
        os.rename(f"{output_path[:-6]}.zip", output_path)
        
        print(f"RMDOC package created at {output_path}")
        return output_path
    
    except Exception as e:
        print(f"Error creating RMDOC package: {e}")
        return None
    
    finally:
        # Clean up the temporary directory
        shutil.rmtree(temp_dir, ignore_errors=True)

def pdf_to_remarkable(pdf_path, output_path=None, resolution=229, create_package=True):
    """
    Convert PDF to Remarkable document format.
    
    Args:
        pdf_path: Path to the input PDF file
        output_path: Optional path for the output file
        resolution: Resolution for the RM file (229 for Remarkable Pro)
        create_package: Whether to create RMDOC package
        
    Returns:
        Path to the output file (RM or RMDOC)
    """
    # Extract the base filename without extension
    if output_path is None:
        base_name = os.path.splitext(pdf_path)[0]
        output_path = f"{base_name}.rmdoc" if create_package else f"{base_name}.rm"
    
    # Extract text from the PDF
    print(f"Extracting text from {pdf_path}")
    text = extract_text_from_pdf(pdf_path)
    
    if not text:
        print("Failed to extract text from PDF")
        return None
    
    # Create an HCL script
    title = os.path.basename(os.path.splitext(pdf_path)[0])
    hcl_path = create_hcl_from_text(text, title=title)
    
    if not hcl_path:
        print("Failed to create HCL script")
        return None
    
    # Create RM file
    rm_path = create_rm_file(hcl_path, resolution=resolution)
    
    if not rm_path:
        print("Failed to create RM file")
        return None
    
    # Create RMDOC package if requested
    if create_package:
        return create_rmdoc_package(rm_path, output_path, title=title)
    else:
        # If the output path is specified and different from the default rm_path
        if output_path != rm_path:
            shutil.copy(rm_path, output_path)
        return output_path

def main():
    parser = argparse.ArgumentParser(description="Convert PDF to Remarkable document format")
    parser.add_argument("input_file", help="Input PDF file path")
    parser.add_argument("-o", "--output", help="Output file path (.rm or .rmdoc)")
    parser.add_argument("-r", "--resolution", type=int, default=229, 
                       help="Resolution for the RM file (default: 229 for Remarkable Pro)")
    parser.add_argument("--rm-only", action="store_true", 
                       help="Create only RM file, not RMDOC package")
    
    args = parser.parse_args()
    
    # Check if input file exists
    if not os.path.exists(args.input_file):
        print(f"Error: Input file '{args.input_file}' not found")
        return 1
    
    # Determine output type based on extension or flag
    create_package = True
    if args.rm_only:
        create_package = False
    elif args.output and args.output.lower().endswith('.rm'):
        create_package = False
    
    # Convert PDF to Remarkable format
    output_path = pdf_to_remarkable(
        args.input_file, 
        output_path=args.output,
        resolution=args.resolution,
        create_package=create_package
    )
    
    if output_path:
        print(f"Conversion successful. Output: {output_path}")
        return 0
    else:
        print("Conversion failed")
        return 1

if __name__ == "__main__":
    sys.exit(main())